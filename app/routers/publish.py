from __future__ import annotations

import html
import re
import json
import asyncio
from pathlib import Path
from typing import Optional, List, Dict, Any

from aiogram import Router, F
from aiogram.types import CallbackQuery, Message, InlineKeyboardMarkup, InlineKeyboardButton
from aiogram.fsm.state import StatesGroup, State
from aiogram.fsm.context import FSMContext
from aiogram.exceptions import TelegramBadRequest
import httpx
from sqlalchemy import select

from app.db import async_session
from app.models import User, Generation, ApiCredentials
from app.crypto import fernet_decrypt
from app.keyboards import back_btn
from app.services.deviantart import DeviantArtClient, DeviantArtError
from app.services.ai_text import OpenAITextClient, DummyTextClient
from app.services.gallery_prefs import get_galleries
from app.user_storage import save_preview, read_preview

router = Router()

SETTINGS_JSON = Path(__file__).resolve().parent.parent / "user_settings.json"

BUYERS_DESC = """\
This adopt is generated by AI Midjourney
After buy, you get a clean image without watermark.
Everyone can also order custom commission art.
You can use anything you want if you buy it!
Paypal accepted.
WHEN YOU BUY, NO RETURNS. Make sure you like it.

THANKS FOR BUYING THIS EXCLUSIVE!
"""

class PublishStates(StatesGroup):
    waiting_images = State()
    waiting_name = State()
    waiting_desc = State()


async def _get_user(tg_id: int, username: Optional[str]) -> User:
    async with async_session() as s:
        res = await s.execute(select(User).where(User.tg_id == tg_id))
        u = res.scalar_one_or_none()
        if not u:
            u = User(tg_id=tg_id, username=username)
            s.add(u)
            await s.commit()
            await s.refresh(u)
        return u


def _normalize_hashtags(tags: List[str]) -> List[str]:
    out: List[str] = []
    seen = set()
    for t in tags or []:
        t = (t or "").strip().lstrip("#")
        if not t:
            continue
        t = re.sub(r"[^A-Za-z0-9_]+", "_", t)
        if not t:
            continue
        key = t.lower()
        if key in seen:
            continue
        seen.add(key)
        out.append(t[:50])
        if len(out) >= 30:
            break
    if not any(x.lower() == "adoptable" for x in out):
        out.append("adoptable")
    return out[:30]


def _prepub_kb() -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup(
        inline_keyboard=[
            [
                InlineKeyboardButton(text="üóÇ –í—ã–±—Ä–∞—Ç—å –≥–∞–ª–µ—Ä–µ—é", callback_data="da:pick_gallery"),
                InlineKeyboardButton(text="üöÄ –û–ø—É–±–ª–∏–∫–æ–≤–∞—Ç—å", callback_data="da:do:publish"),
            ],
            [back_btn("editor")],
        ]
    )


async def _get_da_client_for_user(user_id: int) -> DeviantArtClient | None:
    async with async_session() as s:
        r = await s.execute(
            select(ApiCredentials).where(
                ApiCredentials.user_id == user_id,
                ApiCredentials.service == "deviantart",
            )
        )
        cred = r.scalar_one_or_none()
        if not cred:
            return None
        access = fernet_decrypt(cred.access_token_enc)
        refresh = fernet_decrypt(getattr(cred, "refresh_token_enc", "") or "") if getattr(
            cred, "refresh_token_enc", None) else None
        return DeviantArtClient(access_token=access, refresh_token=refresh, user_id=user_id)


async def _download_image(url: str) -> tuple[bytes, str]:
    async with httpx.AsyncClient(timeout=90.0) as cli:
        r = await cli.get(url)
        r.raise_for_status()
        ct = r.headers.get("content-type", "")
        ext = ".png" if "png" in ct else ".jpg"
        return r.content, f"image{ext}"


def _read_last_urls_for_user(tg_user_id: int) -> List[str]:
    try:
        if SETTINGS_JSON.exists():
            data = json.loads(SETTINGS_JSON.read_text(encoding="utf-8") or "{}")
            obj = data.get(str(tg_user_id)) or {}
            arr = obj.get("last_image_urls") or []
            if isinstance(arr, list):
                out = [u for u in arr if isinstance(u, str) and u.strip()]
                return out[:20]
    except Exception:
        pass
    return []


def _save_pack_to_cache(tg_user_id: int, pack: Dict[str, Any]) -> None:
    try:
        data: Dict[str, Any] = {}
        if SETTINGS_JSON.exists():
            data = json.loads(SETTINGS_JSON.read_text(encoding="utf-8") or "{}")
        obj = data.get(str(tg_user_id)) or {}
        obj["last_da_pack"] = {
            "title": pack.get("title") or "",
            "description": pack.get("description") or "",
            "hashtags": list(pack.get("hashtags") or []),
        }
        data[str(tg_user_id)] = obj
        SETTINGS_JSON.write_text(json.dumps(data, ensure_ascii=False, indent=2), encoding="utf-8")
    except Exception:
        pass


def _read_pack_from_cache(tg_user_id: int) -> Optional[Dict[str, Any]]:
    try:
        if SETTINGS_JSON.exists():
            data = json.loads(SETTINGS_JSON.read_text(encoding="utf-8") or "{}")
            obj = data.get(str(tg_user_id)) or {}
            pack = obj.get("last_da_pack")
            if isinstance(pack, dict):
                return {
                    "title": str(pack.get("title") or ""),
                    "description": str(pack.get("description") or ""),
                    "hashtags": list(pack.get("hashtags") or []),
                }
    except Exception:
        pass
    return None


def _get_ai_client():
    try:
        return OpenAITextClient()
    except Exception:
        return DummyTextClient()


@router.callback_query(F.data == "da:publish")
async def da_publish_start(cb: CallbackQuery):
    try:
        wait_msg = await cb.message.answer("–ì–æ—Ç–æ–≤–ª—é –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä‚Ä¶")
    except Exception:
        wait_msg = None

    u = await _get_user(cb.from_user.id, cb.from_user.username)
    async with async_session() as s:
        r = await s.execute(
            select(Generation).where(Generation.user_id == u.id).order_by(Generation.id.desc())
        )
        gen = r.scalars().first()

    if not gen:
        await cb.message.answer("–ù–µ—Ç –≥–æ—Ç–æ–≤—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏.")
        await cb.answer(); return

    urls = _read_last_urls_for_user(cb.from_user.id)
    if not urls and getattr(gen, "image_url", None):
        urls = [gen.image_url]

    prompt_text = (getattr(gen, "description", None) or getattr(gen, "prompt", "") or "").strip()

    ai = _get_ai_client()
    try:
        pack = await ai.deviantart_pack(prompt_text)
    except Exception:
        base_title = (getattr(gen, "title", None) or "Adoptable").strip()
        tags_raw: List[str] = []
        if getattr(gen, "tags_csv", None):
            tags_raw = [t.strip() for t in str(gen.tags_csv).split(",") if t.strip()]
        if not tags_raw:
            tags_raw = re.findall(r"[A-Za-z0-9_]+", prompt_text.lower())
        pack = {
            "title": base_title or "Adoptable",
            "description": prompt_text,
            "hashtags": _normalize_hashtags(tags_raw) or ["adoptable"],
        }
    finally:
        try:
            await ai.aclose()
        except Exception:
            pass

    _save_pack_to_cache(cb.from_user.id, pack)

    tags_preview = " ".join((pack.get("hashtags") or [])[:30])
    preview = f"""<b>DeviantArt ‚Äî –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä –ø–æ—Å—Ç–∞</b>
<b>–ö–∞–¥—Ä–æ–≤ –≤ –ø–∞—á–∫–µ:</b> {len(urls)}
<b>Title (–Ω—É–º–µ—Ä–∞—Ü–∏—è –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏):</b> {html.escape(pack.get('title',''))} (1), (2), ‚Ä¶

<b>Description:</b>
<code>{html.escape((pack.get('description') or '')[:2000])}</code>

<b>Hashtags ({len(pack.get('hashtags') or [])}):</b> {tags_preview}"""

    save_preview(cb.from_user.id, preview)

    try:
        if wait_msg:
            await wait_msg.delete()
    except Exception:
        pass

    await cb.message.answer(preview, reply_markup=_prepub_kb())
    await cb.answer()


@router.message(PublishStates.waiting_desc)
async def receive_desc(msg: Message, state: FSMContext):
    data = await state.get_data()
    photos = data.get("photos", [])
    name = data.get("name", "Adoptable")
    keywords = (msg.text or "").strip()

    ai = _get_ai_client()
    try:
        pack = await ai.deviantart_pack(keywords or name)
    except Exception:
        tags_raw = re.findall(r"[A-Za-z0-9_]+", (keywords or name).lower())
        pack = {
            "title": name or "Adoptable",
            "description": keywords or name,
            "hashtags": _normalize_hashtags(tags_raw) or ["adoptable"],
        }
    finally:
        try:
            await ai.aclose()
        except Exception:
            pass

    urls = [f"tg://file_id/{pid}" for pid in photos]
    _save_pack_to_cache(msg.from_user.id, pack)

    preview = f"""<b>DeviantArt ‚Äî –ø—Ä–µ–¥–ø—Ä–æ—Å–º–æ—Ç—Ä</b>
<b>–ö–∞–¥—Ä–æ–≤ –≤ –ø–∞—á–∫–µ:</b> {len(urls)}
<b>Title (–Ω—É–º–µ—Ä–∞—Ü–∏—è –ø—Ä–∏ –ø—É–±–ª–∏–∫–∞—Ü–∏–∏):</b> {html.escape(pack['title'])} (1), (2), ‚Ä¶

<b>Description:</b>
<code>{html.escape(pack['description'][:2000])}</code>

<b>Hashtags ({len(pack['hashtags'])}):</b> {" ".join(pack['hashtags'])}"""

    save_preview(msg.from_user.id, preview)

    await msg.answer(preview, reply_markup=_prepub_kb())
    await state.clear()


@router.callback_query(F.data == "da:do:publish")
async def da_do_publish(cb: CallbackQuery):
    u = await _get_user(cb.from_user.id, cb.from_user.username)
    client = await _get_da_client_for_user(u.id)
    if not client:
        await cb.message.answer("–°–Ω–∞—á–∞–ª–∞ –ø–æ–¥–∫–ª—é—á–∏—Ç–µ DeviantArt –≤ –ø—Ä–æ—Ñ–∏–ª–µ.")
        await cb.answer(); return

    async with async_session() as s:
        r = await s.execute(select(Generation).where(Generation.user_id == u.id).order_by(Generation.id.desc()))
        gen = r.scalars().first()
    if not gen:
        await cb.message.answer("–ù–µ—Ç –≥–æ—Ç–æ–≤—ã—Ö –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –ø—É–±–ª–∏–∫–∞—Ü–∏–∏.")
        await cb.answer(); return

    urls = _read_last_urls_for_user(cb.from_user.id)
    if not urls and getattr(gen, "image_url", None):
        urls = [gen.image_url]
    if not urls:
        await cb.message.answer("–ù–µ –Ω–∞–π–¥–µ–Ω–æ URL –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –¥–ª—è –ø–∞—á–∫–∏.")
        await cb.answer(); return

    pack = _read_pack_from_cache(cb.from_user.id) or {}
    base_title = pack.get("title") or (getattr(gen, "title", None) or "Adoptable")
    description = pack.get("description") or (getattr(gen, "description", None) or getattr(gen, "prompt", ""))
    tags = _normalize_hashtags([t.lstrip('#') for t in (pack.get("hashtags") or [])]) or ["adoptable"]

    prefs = get_galleries(u.id)
    gallery_ids = prefs.get("ids", [])  # –µ—Å–ª–∏ –ø—É—Å—Ç–æ ‚Üí Featured

    results: List[str] = []
    errors: List[str] = []

    contents: List[tuple[bytes, str]] = []
    for idx, url in enumerate(urls, 1):
        try:
            contents.append(await _download_image(url))
        except Exception as e:
            errors.append(f"[{idx}] download: {e}")
        await asyncio.sleep(0.05)

    try:
        for idx, (content, fname) in enumerate(contents, 1):
            try:
                # A) buyers –≤ Sta.sh
                await client.stash_submit(
                    file_bytes=content,
                    filename=fname,
                    title="for buyers",
                    artist_comments=BUYERS_DESC,
                    tags=None,
                    is_dirty=False,
                    is_ai_generated=True,
                    noai=False,
                )

                # B) –≤—Ä–µ–º–µ–Ω–Ω—ã–π item —Å –ù–£–ú–ï–†–ê–¶–ò–ï–ô (idx)
                per_title = f"{base_title} ({idx})"
                tmp_item = await client.stash_submit(
                    file_bytes=content,
                    filename=fname,
                    title=per_title,
                    artist_comments=description,
                    tags=tags,  # –ø–æ–π–¥—É—Ç –∫–∞–∫ tags[]
                    is_dirty=False,
                    is_ai_generated=True,
                    noai=False,
                )
                tmp_id = str(tmp_item.get("itemid") or "")
                if not tmp_id:
                    raise DeviantArtError(f"Unexpected stash response: {tmp_item}")

                pub = await client.stash_publish(
                    itemid=tmp_id,
                    is_mature=False,
                    galleryids=gallery_ids or None,
                    tags=tags,  # –ø–æ–π–¥—É—Ç –∫–∞–∫ tags[]
                    is_ai_generated=True,
                    noai=False,
                    add_watermark=True,
                    display_resolution=2,
                    feature=True,
                    allow_comments=True,
                    allow_free_download=False,
                )
                results.append(pub.get("url") or f"id:{pub.get('deviationid')}")
            except Exception as e:
                errors.append(f"[{idx}] publish: {e}")
    finally:
        try:
            await client.aclose()
        except Exception:
            pass

    if results:
        txt = "–û–ø—É–±–ª–∏–∫–æ–≤–∞–Ω–æ ‚úÖ\n" + "\n".join(f"‚Ä¢ {html.escape(x)}" for x in results)
        if errors:
            txt += "\n‚ö†Ô∏è –û—à–∏–±–∫–∏:\n" + "\n".join(errors)
        await cb.message.answer(txt)
    else:
        await cb.message.answer("‚ùå –ü—É–±–ª–∏–∫–∞—Ü–∏—è –Ω–µ —É–¥–∞–ª–∞—Å—å.\n" + ("\n".join(errors) if errors else ""))
